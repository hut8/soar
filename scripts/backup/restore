#!/bin/bash
#
# restore - Restore PostgreSQL database from pg_dump backup
#
# This script restores a single database from a pg_dump backup file.
# It drops and recreates the target database, then restores from the dump.
#
# **WARNING**: This will DROP and recreate the target database!
# Other databases on the same PostgreSQL instance are NOT affected.
#
# Usage:
#   restore                           # Restore from latest backup
#   restore --backup YYYY-MM-DD       # Restore from specific backup
#   restore --yes                     # Skip confirmation prompt
#
# Options:
#   --backup YYYY-MM-DD   Use specific backup (default: latest)
#   --yes                 Skip confirmation prompt (dangerous!)
#
# Exit codes:
#   0 - Success
#   1 - Failure
#   2 - User cancelled
#
# Configuration:
#   Source credentials from /etc/soar/backup-env

set -euo pipefail

# Load configuration
if [[ ! -f /etc/soar/backup-env ]]; then
    echo "ERROR: /etc/soar/backup-env not found" >&2
    exit 1
fi

source /etc/soar/backup-env

# Parse arguments
BACKUP_DATE=""
SKIP_CONFIRM=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --backup|--base-backup)
            BACKUP_DATE="$2"
            shift 2
            ;;
        --latest)
            # Accepted for backwards compatibility (now the default)
            shift
            ;;
        --yes)
            SKIP_CONFIRM=true
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Usage: restore [--backup YYYY-MM-DD] [--yes]" >&2
            exit 1
            ;;
    esac
done

# Rclone configuration
RCLONE_REMOTE="${BACKUP_RCLONE_REMOTE:-wasabi}"
RCLONE_BUCKET="${BACKUP_RCLONE_BUCKET:-soar-backup-prod}"
RCLONE_PATH="${BACKUP_RCLONE_PATH:-}"
RCLONE_CONFIG="${RCLONE_CONFIG:-/etc/soar/rclone.conf}"

# Validate configuration
if [[ -z "${BACKUP_RCLONE_REMOTE:-}" ]]; then
    echo "ERROR: BACKUP_RCLONE_REMOTE not set in /etc/soar/backup-env" >&2
    exit 1
fi

if [[ -z "${BACKUP_RCLONE_BUCKET:-}" ]]; then
    echo "ERROR: BACKUP_RCLONE_BUCKET not set in /etc/soar/backup-env" >&2
    exit 1
fi

# Construct full remote path
if [[ -n "$RCLONE_PATH" ]]; then
    BACKUP_REMOTE="${RCLONE_REMOTE}:${RCLONE_BUCKET}/${RCLONE_PATH}"
else
    BACKUP_REMOTE="${RCLONE_REMOTE}:${RCLONE_BUCKET}"
fi

if [[ ! -f "$RCLONE_CONFIG" ]]; then
    echo "ERROR: Rclone config not found: $RCLONE_CONFIG" >&2
    exit 1
fi

# Directories - use fallbacks for non-root users
TEMP_DIR="${BACKUP_TEMP_DIR:-/var/lib/soar/backup-temp}"
LOG_DIR="${BACKUP_LOG_DIR:-/var/log/soar}"

if ! mkdir -p "$TEMP_DIR" 2>/dev/null || ! [[ -w "$TEMP_DIR" ]]; then
    TEMP_DIR="${HOME}/.local/share/soar/backup-temp"
    mkdir -p "$TEMP_DIR"
fi
if ! mkdir -p "$LOG_DIR" 2>/dev/null || ! [[ -w "$LOG_DIR" ]]; then
    LOG_DIR="${HOME}/.local/share/soar/logs"
    mkdir -p "$LOG_DIR"
fi

# PostgreSQL configuration
PGHOST="${PGHOST:-localhost}"
PGPORT="${PGPORT:-5432}"
PGDATABASE="${PGDATABASE:-soar}"
PGUSER="${PGUSER:-postgres}"
PARALLEL_JOBS="${BACKUP_PARALLEL_JOBS:-4}"

# Restore configuration
RESTORE_DIR="$TEMP_DIR/restore-$(date +%Y%m%d-%H%M%S)"
DOWNLOAD_DIR="$RESTORE_DIR/download"

# Function to log messages (writes to stderr so it doesn't interfere with captured output)
log() {
    local level="$1"
    shift
    local msg="[$(date -u +"%Y-%m-%d %H:%M:%S UTC")] [$level] Restore: $*"
    echo "$msg" >> "$LOG_DIR/restore.log"
    echo "$msg" >&2
}

# Function to cleanup on exit
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]] && [[ $exit_code -ne 2 ]]; then
        log ERROR "Restore failed with exit code $exit_code"
    fi

    # Remove temporary files (but keep them on failure for debugging)
    if [[ $exit_code -eq 0 ]] && [[ -d "$RESTORE_DIR" ]]; then
        log INFO "Cleaning up temporary directory: $RESTORE_DIR"
        rm -rf "$RESTORE_DIR"
    elif [[ -d "$RESTORE_DIR" ]]; then
        log WARN "Keeping temporary directory for debugging: $RESTORE_DIR"
    fi
}

trap cleanup EXIT

# Function to confirm destructive operation
confirm_restore() {
    if [[ "$SKIP_CONFIRM" == "true" ]]; then
        return 0
    fi

    echo ""
    echo "╔════════════════════════════════════════════════════════════════╗"
    echo "║                   ⚠️  WARNING: DESTRUCTIVE OPERATION  ⚠️        ║"
    echo "╚════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "This will:"
    echo "  1. DROP the database: $PGDATABASE"
    echo "  2. Recreate the database"
    echo "  3. Restore from backup using pg_restore"
    echo ""
    echo "Other databases on this PostgreSQL instance will NOT be affected."
    echo ""
    echo "Database: $PGDATABASE"
    echo "Server: $PGHOST:$PGPORT"
    echo "Backup source: $BACKUP_REMOTE"
    echo ""
    read -p "Type 'yes' to proceed: " response
    echo ""

    if [[ "$response" != "yes" ]]; then
        log INFO "Restore cancelled by user"
        exit 2
    fi

    log INFO "User confirmed restore operation"
}

# Function to find backup
find_backup() {
    log INFO "Finding backup..."

    if [[ -n "$BACKUP_DATE" ]]; then
        # User specified a specific backup
        if rclone lsd "${BACKUP_REMOTE}/base/${BACKUP_DATE}/" \
            --config "$RCLONE_CONFIG" \
            >/dev/null 2>&1; then
            echo "$BACKUP_DATE"
            return 0
        else
            log ERROR "Specified backup does not exist: $BACKUP_DATE"
            exit 1
        fi
    else
        # Find most recent backup
        local newest=$(rclone lsd "${BACKUP_REMOTE}/base/" \
            --config "$RCLONE_CONFIG" \
            2>/dev/null | awk '{print $5}' | sort -r | head -1 || echo "")

        if [[ -z "$newest" ]]; then
            log ERROR "No backups found"
            exit 1
        fi

        echo "$newest"
    fi
}

# Function to download backup
download_backup() {
    local backup_date="$1"
    local backup_prefix="${BACKUP_REMOTE}/base/${backup_date}"

    log INFO "Downloading backup: $backup_date"
    log INFO "Source: $backup_prefix"

    mkdir -p "$DOWNLOAD_DIR"

    # Download all files
    if ! rclone sync "$backup_prefix/" "$DOWNLOAD_DIR/" \
        --config "$RCLONE_CONFIG" \
        --progress \
        2>&1 | tee -a "$LOG_DIR/restore.log"; then
        log ERROR "Failed to download backup"
        exit 1
    fi

    # Verify download - check for pg_dump directory format
    if [[ ! -d "$DOWNLOAD_DIR/database" ]]; then
        log ERROR "Backup is incomplete (missing database directory)"
        log ERROR "This restore script requires pg_dump directory format backups."
        log ERROR "Found files: $(ls -la "$DOWNLOAD_DIR/")"
        exit 1
    fi

    log INFO "Backup downloaded successfully"

    # Show backup metadata if available
    if [[ -f "$DOWNLOAD_DIR/backup-metadata.json" ]]; then
        log INFO "Backup metadata:"
        jq . "$DOWNLOAD_DIR/backup-metadata.json" 2>/dev/null | while read -r line; do
            log INFO "  $line"
        done
    fi
}

# Function to restore database
restore_database() {
    local dump_dir="$DOWNLOAD_DIR/database"

    log INFO "Dropping existing database: $PGDATABASE"

    # Terminate existing connections to the database
    psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d postgres -c \
        "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$PGDATABASE' AND pid <> pg_backend_pid();" \
        >/dev/null 2>&1 || true

    # Drop database if it exists
    if psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d postgres -lqt | cut -d \| -f 1 | grep -qw "$PGDATABASE"; then
        if ! dropdb -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" "$PGDATABASE"; then
            log ERROR "Failed to drop database: $PGDATABASE"
            exit 1
        fi
        log INFO "Database dropped"
    else
        log INFO "Database does not exist, will create new"
    fi

    # Create fresh database
    log INFO "Creating database: $PGDATABASE"
    if ! createdb -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" "$PGDATABASE"; then
        log ERROR "Failed to create database: $PGDATABASE"
        exit 1
    fi

    # Restore from dump using pg_restore
    log INFO "Restoring from backup using pg_restore (parallel jobs: $PARALLEL_JOBS)..."
    log INFO "This may take a while for large databases..."

    if ! pg_restore \
        -h "$PGHOST" \
        -p "$PGPORT" \
        -U "$PGUSER" \
        -d "$PGDATABASE" \
        -j "$PARALLEL_JOBS" \
        -v \
        "$dump_dir" \
        2>&1 | tee -a "$LOG_DIR/restore.log"; then
        # pg_restore returns non-zero on warnings too, check if database is accessible
        if ! psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c "SELECT 1" >/dev/null 2>&1; then
            log ERROR "pg_restore failed and database is not accessible"
            exit 1
        fi
        log WARN "pg_restore completed with warnings (this is often normal)"
    fi

    log INFO "Database restored successfully"
}

# Function to verify restore
verify_restore() {
    log INFO "Verifying restored database..."

    # Connect to database
    if ! psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c "SELECT 1" >/dev/null 2>&1; then
        log ERROR "Cannot connect to restored database"
        exit 1
    fi

    # Get database stats
    local db_size=$(psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -t -c \
        "SELECT pg_database_size('$PGDATABASE')" | tr -d ' ')
    local device_count=$(psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -t -c \
        "SELECT COUNT(*) FROM devices" 2>/dev/null | tr -d ' ' || echo "N/A")
    local table_count=$(psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -t -c \
        "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public'" | tr -d ' ')

    log INFO "Restored database stats:"
    log INFO "  Database size: $(numfmt --to=iec-i --suffix=B "$db_size")"
    log INFO "  Tables: $table_count"
    if [[ "$device_count" != "N/A" ]]; then
        log INFO "  Devices: $device_count"
    fi

    log INFO "Database verification passed"
}

# Main restore function
main() {
    local start_time=$(date +%s)

    log INFO "=========================================="
    log INFO "Starting database restore"
    log INFO "=========================================="
    log INFO "Database: $PGDATABASE"
    log INFO "Server: $PGHOST:$PGPORT"

    # Confirm operation
    confirm_restore

    # Find backup
    local backup=$(find_backup)
    log INFO "Using backup: $backup"

    # Download backup
    download_backup "$backup"

    # Restore database
    restore_database

    # Verify restore
    verify_restore

    # Calculate duration
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local duration_formatted=$(printf '%02d:%02d:%02d' $((duration/3600)) $((duration%3600/60)) $((duration%60)))

    log INFO "=========================================="
    log INFO "Restore completed successfully!"
    log INFO "Duration: $duration_formatted"
    log INFO "=========================================="
    log INFO ""
    log INFO "Next steps:"
    log INFO "  1. Verify application functionality"
    log INFO "  2. Restart application services if needed"
    log INFO ""

    return 0
}

# Run main function
main

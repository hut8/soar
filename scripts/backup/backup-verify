#!/bin/bash
#
# backup-verify - Verify integrity of database backups
#
# This script verifies that backups are valid, complete, and restorable.
# It checks base backup integrity, WAL continuity, and backup age.
#
# Usage:
#   backup-verify [backup_date]
#
# Arguments:
#   backup_date - Optional: Specific backup date to verify (YYYY-MM-DD format)
#                 If omitted, verifies all backups within retention period
#
# Exit codes:
#   0 - All verifications passed
#   1 - One or more verifications failed
#
# Configuration:
#   Source credentials from /etc/soar/backup-env
#
# Scheduling:
#   Run via systemd timer: soar-backup-verify.timer (weekly, Monday 3 AM)

set -euo pipefail

# Load configuration
if [[ ! -f /etc/soar/backup-env ]]; then
    echo "ERROR: /etc/soar/backup-env not found" >&2
    exit 1
fi

source /etc/soar/backup-env

# Parse arguments
SPECIFIC_BACKUP="${1:-}"

# Validate configuration
if [[ -z "${BACKUP_REMOTE:-}" ]]; then
    echo "ERROR: BACKUP_REMOTE not set in /etc/soar/backup-env" >&2
    exit 1
fi

# Rclone configuration
RCLONE_CONFIG="${RCLONE_CONFIG:-/etc/soar/rclone.conf}"
if [[ ! -f "$RCLONE_CONFIG" ]]; then
    echo "ERROR: Rclone config not found: $RCLONE_CONFIG" >&2
    exit 1
fi

# Directories
LOG_DIR="${BACKUP_LOG_DIR:-/var/log/soar}"
mkdir -p "$LOG_DIR"

# Retention configuration
RETENTION_DAYS="${BACKUP_RETENTION_DAYS:-30}"

# Verification thresholds
MAX_BACKUP_AGE_DAYS=8  # Alert if newest base backup > 8 days old
MAX_WAL_AGE_MINUTES=15 # Alert if newest WAL > 15 minutes old

# Notifications
NOTIFY_EMAIL="${BACKUP_NOTIFY_EMAIL:-}"
NOTIFY_SLACK="${BACKUP_NOTIFY_SLACK_WEBHOOK:-}"
SENTRY_DSN="${SENTRY_DSN:-}"

# Counters
TOTAL_CHECKS=0
PASSED_CHECKS=0
FAILED_CHECKS=0
WARNINGS=0

# Function to log messages
log() {
    local level="$1"
    shift
    echo "[$(date -u +"%Y-%m-%d %H:%M:%S UTC")] [$level] Backup Verify: $*" | tee -a "$LOG_DIR/backup.log"
}

# Function to increment check counters
check_result() {
    local result="$1"  # "PASS", "FAIL", or "WARN"
    local message="$2"

    ((TOTAL_CHECKS++))

    case "$result" in
        PASS)
            ((PASSED_CHECKS++))
            log INFO "✓ PASS: $message"
            ;;
        FAIL)
            ((FAILED_CHECKS++))
            log ERROR "✗ FAIL: $message"
            ;;
        WARN)
            ((WARNINGS++))
            log WARN "⚠ WARN: $message"
            ;;
    esac
}

# Function to send notifications
notify() {
    local status="$1"
    local message="$2"

    log INFO "Notification: $status - $message"

    # Email notification
    if [[ -n "$NOTIFY_EMAIL" ]] && command -v mail >/dev/null 2>&1; then
        echo "$message" | mail -s "SOAR Backup Verification: $status" "$NOTIFY_EMAIL"
    fi

    # Slack notification
    if [[ -n "$NOTIFY_SLACK" ]] && command -v curl >/dev/null 2>&1; then
        curl -X POST "$NOTIFY_SLACK" \
            -H 'Content-Type: application/json' \
            -d "{\"text\":\"SOAR Backup Verification: $status\n$message\"}" \
            >/dev/null 2>&1 || true
    fi

    # Sentry notification
    if [[ -n "$SENTRY_DSN" ]] && command -v curl >/dev/null 2>&1; then
        # Extract project ID and key from DSN
        local sentry_key=$(echo "$SENTRY_DSN" | sed -n 's|https://\([^@]*\)@.*|\1|p')
        local sentry_host=$(echo "$SENTRY_DSN" | sed -n 's|https://[^@]*@\([^/]*\).*|\1|p')
        local sentry_project=$(echo "$SENTRY_DSN" | sed -n 's|.*/\([0-9]*\)$|\1|p')

        if [[ -n "$sentry_key" ]] && [[ -n "$sentry_host" ]] && [[ -n "$sentry_project" ]]; then
            local event_level="info"
            [[ "$status" == "FAILED" ]] && event_level="error"
            [[ "$status" == "WARNING" ]] && event_level="warning"
            [[ "$status" == "SUCCESS" ]] && event_level="info"

            local event_payload=$(cat <<EOF
{
  "event_id": "$(uuidgen | tr -d '-' | tr '[:upper:]' '[:lower:]')",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%S")",
  "platform": "other",
  "level": "$event_level",
  "logger": "soar-backup",
  "message": "SOAR Backup Verification: $status",
  "extra": {
    "total_checks": $TOTAL_CHECKS,
    "passed_checks": $PASSED_CHECKS,
    "failed_checks": $FAILED_CHECKS,
    "warnings": $WARNINGS,
    "hostname": "$(hostname)",
    "message": "$message",
    "script": "backup-verify"
  },
  "tags": {
    "backup_type": "verification",
    "status": "$status",
    "environment": "production"
  }
}
EOF
)

            curl -X POST "https://${sentry_host}/api/${sentry_project}/store/" \
                -H "X-Sentry-Auth: Sentry sentry_version=7, sentry_key=${sentry_key}, sentry_client=soar-backup/1.0" \
                -H 'Content-Type: application/json' \
                -d "$event_payload" \
                >/dev/null 2>&1 || true
        fi
    fi
}

# Function to convert date to timestamp
date_to_timestamp() {
    date -d "$1" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$1" +%s 2>/dev/null || echo 0
}

# Function to verify a single base backup
verify_base_backup() {
    local backup_date="$1"
    local backup_prefix="${BACKUP_REMOTE}/base/${backup_date}"

    log INFO "Verifying base backup: $backup_date"

    # Check if backup exists
    if ! rclone lsd "$backup_prefix/" \
        --config "$RCLONE_CONFIG" \
        >/dev/null 2>&1; then
        check_result FAIL "Base backup does not exist: $backup_date"
        return 1
    fi

    # List files in backup
    local files=$(rclone lsf "$backup_prefix/" \
        --config "$RCLONE_CONFIG" \
        2>/dev/null || echo "")

    if [[ -z "$files" ]]; then
        check_result FAIL "Base backup directory is empty: $backup_date"
        return 1
    fi

    # Check for required files
    if echo "$files" | grep -q "base.tar.gz"; then
        check_result PASS "Base backup has base.tar.gz: $backup_date"
    else
        check_result FAIL "Base backup missing base.tar.gz: $backup_date"
        return 1
    fi

    # Check for metadata file
    if rclone lsf "$backup_prefix/backup-metadata.json" \
        --config "$RCLONE_CONFIG" \
        >/dev/null 2>&1; then
        check_result PASS "Base backup has metadata: $backup_date"

        # Download and parse metadata
        local metadata=$(rclone cat "$backup_prefix/backup-metadata.json" \
            --config "$RCLONE_CONFIG" \
            2>/dev/null || echo "{}")

        if [[ -n "$metadata" ]] && echo "$metadata" | jq . >/dev/null 2>&1; then
            local db_size=$(echo "$metadata" | jq -r '.database_size_bytes // 0')
            local backup_size=$(echo "$metadata" | jq -r '.backup_size_bytes // 0')

            log INFO "  Database size: $(numfmt --to=iec-i --suffix=B "$db_size")"
            log INFO "  Backup size: $(numfmt --to=iec-i --suffix=B "$backup_size")"
        fi
    else
        check_result WARN "Base backup missing metadata file: $backup_date"
    fi

    # Calculate backup age
    local backup_timestamp=$(date_to_timestamp "$backup_date")
    local now_timestamp=$(date +%s)
    local age_days=$(( (now_timestamp - backup_timestamp) / 86400 ))

    log INFO "  Backup age: $age_days days"

    return 0
}

# Function to verify WAL continuity
verify_wal_continuity() {
    log INFO "Verifying WAL continuity..."

    # List WAL files (limit to recent files for performance)
    local wal_list=$(rclone ls "${BACKUP_REMOTE}/wal/" \
        --config "$RCLONE_CONFIG" \
        --max-depth 1 \
        2>/dev/null | tail -100 || echo "")

    if [[ -z "$wal_list" ]]; then
        check_result FAIL "No WAL files found in cloud storage"
        return 1
    fi

    local wal_count=$(echo "$wal_list" | wc -l)
    check_result PASS "Found $wal_count recent WAL files"

    # Check age of newest WAL file
    local newest_wal=$(echo "$wal_list" | tail -1)
    if [[ -n "$newest_wal" ]]; then
        local wal_date=$(echo "$newest_wal" | awk '{print $1, $2}')
        local wal_timestamp=$(date -d "$wal_date" +%s 2>/dev/null || echo 0)
        local now_timestamp=$(date +%s)
        local wal_age_minutes=$(( (now_timestamp - wal_timestamp) / 60 ))

        log INFO "Newest WAL file age: $wal_age_minutes minutes"

        if [[ $wal_age_minutes -lt $MAX_WAL_AGE_MINUTES ]]; then
            check_result PASS "WAL archiving is current (< $MAX_WAL_AGE_MINUTES minutes)"
        else
            check_result WARN "WAL archiving may be lagging ($wal_age_minutes minutes old)"
        fi
    fi

    # Basic continuity check (look for gaps in sequence)
    # This is simplified - full check would need to parse WAL filenames
    local wal_files=$(echo "$wal_list" | awk '{print $4}' | sort)
    local wal_file_count=$(echo "$wal_files" | wc -l)

    if [[ $wal_file_count -gt 1 ]]; then
        check_result PASS "WAL sequence appears continuous (basic check)"
    fi

    return 0
}

# Function to check backup freshness
check_backup_freshness() {
    log INFO "Checking backup freshness..."

    # Find newest base backup
    local newest_backup=$(rclone lsd "${BACKUP_REMOTE}/base/" \
        --config "$RCLONE_CONFIG" \
        2>/dev/null | awk '{print $5}' | sort -r | head -1 || echo "")

    if [[ -z "$newest_backup" ]]; then
        check_result FAIL "No base backups found"
        return 1
    fi

    log INFO "Newest base backup: $newest_backup"

    # Calculate age
    local backup_timestamp=$(date_to_timestamp "$newest_backup")
    local now_timestamp=$(date +%s)
    local age_days=$(( (now_timestamp - backup_timestamp) / 86400 ))

    log INFO "Base backup age: $age_days days"

    if [[ $age_days -le $MAX_BACKUP_AGE_DAYS ]]; then
        check_result PASS "Base backup is fresh (< $MAX_BACKUP_AGE_DAYS days old)"
    else
        check_result FAIL "Base backup is stale ($age_days days old, should be < $MAX_BACKUP_AGE_DAYS)"
    fi

    return 0
}

# Function to check storage usage
check_storage_usage() {
    log INFO "Checking storage usage..."

    # Get total size of backups (rclone size returns JSON)
    local base_size=$(rclone size "${BACKUP_REMOTE}/base/" \
        --config "$RCLONE_CONFIG" \
        --json 2>/dev/null | jq -r '.bytes // 0' || echo "0")

    local wal_size=$(rclone size "${BACKUP_REMOTE}/wal/" \
        --config "$RCLONE_CONFIG" \
        --json 2>/dev/null | jq -r '.bytes // 0' || echo "0")

    local total_size=$((base_size + wal_size))

    log INFO "Base backups: $(numfmt --to=iec-i --suffix=B "$base_size")"
    log INFO "WAL archives: $(numfmt --to=iec-i --suffix=B "$wal_size")"
    log INFO "Total storage: $(numfmt --to=iec-i --suffix=B "$total_size")"

    # Basic sanity check: total storage should be reasonable
    # For a 420GB database, expect ~500GB-1TB in cloud
    if [[ $total_size -gt 0 ]]; then
        check_result PASS "Storage usage appears reasonable"
    else
        check_result FAIL "Storage usage calculation failed or no data found"
    fi

    return 0
}

# Function to print summary
print_summary() {
    log INFO "=========================================="
    log INFO "Verification Summary"
    log INFO "=========================================="
    log INFO "Total checks: $TOTAL_CHECKS"
    log INFO "Passed: $PASSED_CHECKS"
    log INFO "Failed: $FAILED_CHECKS"
    log INFO "Warnings: $WARNINGS"
    log INFO "=========================================="

    if [[ $FAILED_CHECKS -eq 0 ]]; then
        log INFO "✓ All verifications PASSED"
        if [[ $WARNINGS -gt 0 ]]; then
            log WARN "⚠ But $WARNINGS warnings were found"
        fi
    else
        log ERROR "✗ $FAILED_CHECKS verification(s) FAILED"
    fi
}

# Main verification function
main() {
    log INFO "=========================================="
    log INFO "Starting backup verification"
    log INFO "=========================================="
    log INFO "Backup remote: $BACKUP_REMOTE"
    log INFO "Retention: $RETENTION_DAYS days"

    # Check cloud connectivity
    log INFO "Testing cloud storage connectivity..."
    if rclone lsd "$BACKUP_REMOTE/" \
        --config "$RCLONE_CONFIG" \
        >/dev/null 2>&1; then
        check_result PASS "Cloud storage is accessible"
    else
        check_result FAIL "Cannot access cloud storage"
        print_summary
        exit 1
    fi

    # Verify specific backup or all backups
    if [[ -n "$SPECIFIC_BACKUP" ]]; then
        log INFO "Verifying specific backup: $SPECIFIC_BACKUP"
        verify_base_backup "$SPECIFIC_BACKUP"
    else
        log INFO "Verifying all backups within retention period..."

        # List all base backups
        local all_backups=$(rclone lsd "${BACKUP_REMOTE}/base/" \
            --config "$RCLONE_CONFIG" \
            2>/dev/null | awk '{print $5}' | sort -r || echo "")

        if [[ -z "$all_backups" ]]; then
            check_result FAIL "No base backups found"
        else
            local backup_count=$(echo "$all_backups" | wc -l)
            log INFO "Found $backup_count base backup(s)"

            for backup_date in $all_backups; do
                verify_base_backup "$backup_date"
            done
        fi

        # Check backup freshness
        check_backup_freshness

        # Verify WAL continuity
        verify_wal_continuity

        # Check storage usage
        check_storage_usage
    fi

    # Print summary
    print_summary

    # Send notifications
    if [[ $FAILED_CHECKS -gt 0 ]]; then
        notify "FAILED" "Backup verification failed on $(hostname)
Total checks: $TOTAL_CHECKS
Passed: $PASSED_CHECKS
Failed: $FAILED_CHECKS
Warnings: $WARNINGS

Check logs at $LOG_DIR/backup.log for details."
    elif [[ $WARNINGS -gt 0 ]]; then
        notify "WARNING" "Backup verification completed with warnings on $(hostname)
Total checks: $TOTAL_CHECKS
Passed: $PASSED_CHECKS
Warnings: $WARNINGS

Check logs at $LOG_DIR/backup.log for details."
    else
        notify "SUCCESS" "Backup verification passed on $(hostname)
Total checks: $TOTAL_CHECKS
All checks passed successfully."
    fi

    # Exit with appropriate code
    if [[ $FAILED_CHECKS -gt 0 ]]; then
        exit 1
    else
        exit 0
    fi
}

# Run main function
main

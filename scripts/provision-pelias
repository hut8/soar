#!/bin/bash
# SOAR Pelias Geocoding Service Provisioning Script
#
# This script provisions a Pelias geocoding server for SOAR by:
# - Installing Elasticsearch 8 with required plugins
# - Downloading and importing Who's on First data (city-level)
# - Setting up Pelias API and PIP services (systemd, not Docker)
# - Installing and configuring Caddy reverse proxy
#
# Usage:
#   sudo ./provision-pelias
#
# Note: This script uses Docker temporarily for data import only.
#       Production services run via systemd.

set -e
set -u
set -o pipefail
set -x

# Save the directory containing this script (repo root/scripts)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo -e "${RED}Error: This script must be run as root (use sudo)${NC}"
   exit 1
fi

echo -e "${GREEN}Provisioning Pelias geocoding server with Elasticsearch 8...${NC}"

# Detect OS
if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS=$ID
else
    echo -e "${RED}Error: Cannot detect OS. /etc/os-release not found.${NC}"
    exit 1
fi

echo -e "${BLUE}Detected OS: $OS${NC}"

# Check if OS is Debian or Ubuntu
if [[ "$OS" != "ubuntu" ]] && [[ "$OS" != "debian" ]]; then
    echo -e "${RED}Error: This script only supports Debian and Ubuntu.${NC}"
    exit 1
fi

# Install prerequisites
echo -e "${BLUE}Installing prerequisites...${NC}"
apt-get update
apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release gpg jq debian-keyring debian-archive-keyring

# Install Elasticsearch 8
echo -e "${BLUE}Installing Elasticsearch 8...${NC}"

# Add Elasticsearch GPG key and repository
if [ ! -f /usr/share/keyrings/elasticsearch-keyring.gpg ]; then
    curl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | \
        gpg --dearmor --batch --yes -o /usr/share/keyrings/elasticsearch-keyring.gpg
fi

if [ ! -f /etc/apt/sources.list.d/elastic-8.x.list ]; then
    echo "deb [signed-by=/usr/share/keyrings/elasticsearch-keyring.gpg] https://artifacts.elastic.co/packages/8.x/apt stable main" | \
        tee /etc/apt/sources.list.d/elastic-8.x.list
fi

apt-get update
apt-get install -y elasticsearch

# Install ICU plugin if not already installed
if /usr/share/elasticsearch/bin/elasticsearch-plugin list | grep -q analysis-icu; then
    echo -e "${BLUE}ICU analysis plugin already installed${NC}"
else
    echo -e "${BLUE}Installing ICU analysis plugin...${NC}"
    /usr/share/elasticsearch/bin/elasticsearch-plugin install analysis-icu --batch
fi

# Add current user and soar user to elasticsearch group for access to logs and config
echo -e "${BLUE}Adding users to elasticsearch group...${NC}"
CURRENT_USER="${SUDO_USER:-$USER}"
if id "$CURRENT_USER" &>/dev/null; then
    usermod -a -G elasticsearch "$CURRENT_USER"
    echo -e "${GREEN}Added $CURRENT_USER to elasticsearch group${NC}"
fi
if id soar &>/dev/null; then
    usermod -a -G elasticsearch soar
    echo -e "${GREEN}Added soar user to elasticsearch group${NC}"
fi

# Configure for Pelias
ELASTICSEARCH_CONFIG_CHANGED=false

# Clean up elasticsearch.yml to ensure no duplicate settings
# ES 8 ships with xpack.security defaults that conflict with our Pelias config
echo -e "${BLUE}Cleaning up elasticsearch.yml...${NC}"

# Remove any existing Pelias configuration block (we'll re-add it fresh)
sed -i '/# Pelias configuration/,/^$/d' /etc/elasticsearch/elasticsearch.yml 2>/dev/null || true

# Remove ES 8 security auto-configuration block entirely (added on first install)
sed -i '/^#----------------------- BEGIN SECURITY AUTO CONFIGURATION/,/^#----------------------- END SECURITY AUTO CONFIGURATION/d' /etc/elasticsearch/elasticsearch.yml 2>/dev/null || true

# Remove any remaining ES 8 default xpack.security settings (we'll set our own)
sed -i '/^xpack\.security/d' /etc/elasticsearch/elasticsearch.yml

# Remove other settings we'll configure
sed -i '/^cluster\.initial_master_nodes/d' /etc/elasticsearch/elasticsearch.yml
sed -i '/^network\.host/d' /etc/elasticsearch/elasticsearch.yml
sed -i '/^http\.host/d' /etc/elasticsearch/elasticsearch.yml
sed -i '/^http\.port/d' /etc/elasticsearch/elasticsearch.yml
sed -i '/^discovery\.type/d' /etc/elasticsearch/elasticsearch.yml

echo -e "${BLUE}Adding Pelias configuration to elasticsearch.yml...${NC}"
cat >> /etc/elasticsearch/elasticsearch.yml <<EOF

# Pelias configuration
discovery.type: single-node
indices.query.bool.max_clause_count: 4096

# Network configuration - HTTP only on localhost
network.host: 127.0.0.1
http.port: 9200

# Disable security features (no HTTPS, no authentication for localhost access)
xpack.security.enabled: false
xpack.security.http.ssl.enabled: false
xpack.security.transport.ssl.enabled: false
EOF
ELASTICSEARCH_CONFIG_CHANGED=true

# Set JVM heap size (8GB - adjust based on RAM)
mkdir -p /etc/elasticsearch/jvm.options.d
cat > /etc/elasticsearch/jvm.options.d/heap.options <<EOF
-Xms8g
-Xmx8g
EOF

# Enable and start/restart Elasticsearch
systemctl daemon-reload
systemctl enable elasticsearch

if [ "$ELASTICSEARCH_CONFIG_CHANGED" = true ]; then
    echo -e "${BLUE}Restarting Elasticsearch to apply configuration changes...${NC}"
    systemctl restart elasticsearch
else
    systemctl start elasticsearch 2>/dev/null || true
fi

echo -e "${GREEN}Elasticsearch configured and running${NC}"

# Wait for search engine to be ready
echo -e "${BLUE}Waiting for Elasticsearch to be ready...${NC}"
for i in {1..30}; do
    if curl -s http://localhost:9200 > /dev/null 2>&1; then
        echo -e "${GREEN}Elasticsearch is ready on localhost${NC}"
        break
    fi
    if [ $i -eq 30 ]; then
        echo -e "${RED}Error: Elasticsearch failed to start${NC}"
        echo -e "${YELLOW}Check logs: journalctl -u elasticsearch -n 50${NC}"
        exit 1
    fi
    sleep 2
done

# Install Docker (for data import tools only)
if ! command -v docker &> /dev/null; then
    echo -e "${BLUE}Installing Docker...${NC}"

    # Add Docker GPG key and repository
    curl -fsSL https://download.docker.com/linux/$OS/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/$OS $(lsb_release -cs) stable" | \
        tee /etc/apt/sources.list.d/docker.list > /dev/null

    apt-get update
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

    # Enable and start Docker daemon
    systemctl enable docker
    systemctl start docker

    echo -e "${GREEN}Docker installed and started${NC}"
else
    echo -e "${BLUE}Docker already installed${NC}"
fi

# Ensure Docker daemon is running
if ! systemctl is-active --quiet docker; then
    echo -e "${BLUE}Starting Docker daemon...${NC}"
    systemctl start docker
fi

# Wait for Docker to be ready
echo -e "${BLUE}Waiting for Docker to be ready...${NC}"
for i in {1..10}; do
    if docker info > /dev/null 2>&1; then
        echo -e "${GREEN}Docker is ready${NC}"
        break
    fi
    if [ $i -eq 10 ]; then
        echo -e "${RED}Error: Docker failed to start${NC}"
        exit 1
    fi
    sleep 2
done

# Install Node.js 20.x LTS (for Pelias services)
if ! command -v node &> /dev/null; then
    echo -e "${BLUE}Installing Node.js 20.x LTS...${NC}"

    curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
    apt-get install -y nodejs

    echo -e "${GREEN}Node.js $(node --version) installed${NC}"
else
    echo -e "${BLUE}Node.js $(node --version) already installed${NC}"
fi

# Create pelias user if it doesn't exist
if ! id "pelias" &>/dev/null; then
    echo -e "${BLUE}Creating 'pelias' system user...${NC}"
    useradd --system --user-group --create-home --home-dir /opt/pelias --shell /bin/bash pelias
    echo -e "${GREEN}'pelias' user created${NC}"
else
    echo -e "${BLUE}'pelias' user already exists${NC}"
fi

# Add pelias user to docker group for Docker access
if ! groups pelias | grep -q docker; then
    echo -e "${BLUE}Adding pelias user to docker group...${NC}"
    usermod -a -G docker pelias
    echo -e "${GREEN}pelias user added to docker group${NC}"
else
    echo -e "${BLUE}pelias user already in docker group${NC}"
fi

# Create base Pelias directory structure
echo -e "${BLUE}Creating Pelias directory structure...${NC}"
mkdir -p /opt/pelias
mkdir -p /opt/pelias/api
mkdir -p /opt/pelias/pip
chown -R pelias:pelias /opt/pelias

# Clone Pelias docker repository (for import tools)
if [ ! -d /opt/pelias/docker/.git ]; then
    echo -e "${BLUE}Cloning Pelias docker repository...${NC}"
    sudo -u pelias git clone https://github.com/pelias/docker.git /opt/pelias/docker
else
    echo -e "${BLUE}Pelias docker repository already exists${NC}"
fi

# Create data directories inside cloned repo
mkdir -p /opt/pelias/docker/data/whosonfirst
mkdir -p /opt/pelias/docker/data/openaddresses
mkdir -p /opt/pelias/docker/data/placeholder
chown -R pelias:pelias /opt/pelias

# Check for OpenAddresses token (required for forward geocoding)
# Token should be in /etc/soar/env-production or /etc/soar/env-staging as OPENADDRESSES_TOKEN=...
OPENADDRESSES_TOKEN=""
if [ -f /etc/soar/env-production ]; then
    source /etc/soar/env-production 2>/dev/null || true
fi
if [ -f /etc/soar/env-staging ]; then
    source /etc/soar/env-staging 2>/dev/null || true
fi

if [ -n "${OPENADDRESSES_TOKEN:-}" ]; then
    echo -e "${GREEN}OpenAddresses token found in environment${NC}"
else
    echo -e "${YELLOW}Warning: OpenAddresses token not found${NC}"
    echo -e "${YELLOW}Forward geocoding will be limited without OpenAddresses data${NC}"
    echo -e "${YELLOW}To enable: add OPENADDRESSES_TOKEN=... to /etc/soar/env-production${NC}"
    echo -e "${YELLOW}Get a free token from https://openaddresses.io${NC}"
fi

# Create pelias.json configuration
echo -e "${BLUE}Creating pelias.json configuration...${NC}"
cat > /opt/pelias/docker/pelias.json <<EOF
{
  "logger": {
    "level": "info",
    "timestamp": true
  },
  "esclient": {
    "hosts": [
      {
        "protocol": "http",
        "host": "127.0.0.1",
        "port": 9200
      }
    ]
  },
  "elasticsearch": {
    "settings": {
      "index": {
        "refresh_interval": "30s",
        "number_of_replicas": "0",
        "number_of_shards": "5"
      }
    }
  },
  "api": {
    "version": "1.0",
    "indexName": "pelias",
    "host": "127.0.0.1",
    "port": 4000,
    "services": {
      "pip": {
        "url": "http://localhost:4200"
      },
      "libpostal": {
        "url": "http://localhost:4400"
      },
      "placeholder": {
        "url": "http://localhost:4100"
      }
    }
  },
  "imports": {
    "adminLookup": {
      "enabled": true
    },
    "whosonfirst": {
      "datapath": "/data/whosonfirst"
    },
    "openaddresses": {
      "datapath": "/data/openaddresses",
      "token": "${OPENADDRESSES_TOKEN}"
    }
  }
}
EOF

chown pelias:pelias /opt/pelias/docker/pelias.json

# Create .env file for Docker
# Note: DOCKER_USER is deprecated and ignored by newer pelias images.
# Containers now run as 1000:1000 by default, so data directories must be writable by that user.
cat > /opt/pelias/docker/.env <<EOF
DATA_DIR=/opt/pelias/docker/data
EOF

chown pelias:pelias /opt/pelias/docker/.env

# Ensure data directories are writable by the container user (1000:1000)
# Newer pelias docker images ignore DOCKER_USER and default to 1000:1000
echo -e "${BLUE}Setting data directory permissions for container access...${NC}"
chown -R 1000:1000 /opt/pelias/docker/data

# Create docker-compose.yml for data import
# Note: user directive removed - newer pelias images ignore DOCKER_USER and run as 1000:1000
echo -e "${BLUE}Creating docker-compose.yml for Pelias data import...${NC}"
cat > /opt/pelias/docker/docker-compose.yml <<'EOF'
services:
  schema:
    image: pelias/schema:master
    container_name: pelias_schema
    network_mode: host
    volumes:
      - "./pelias.json:/code/pelias.json"
  whosonfirst:
    image: pelias/whosonfirst:master
    container_name: pelias_whosonfirst
    network_mode: host
    volumes:
      - "./pelias.json:/code/pelias.json"
      - "${DATA_DIR}:/data"
  openaddresses:
    image: pelias/openaddresses:master
    container_name: pelias_openaddresses
    network_mode: host
    volumes:
      - "./pelias.json:/code/pelias.json"
      - "${DATA_DIR}:/data"
  placeholder:
    image: pelias/placeholder:master
    container_name: pelias_placeholder
    network_mode: host
    volumes:
      - "./pelias.json:/code/pelias.json"
      - "${DATA_DIR}:/data"
EOF

chown pelias:pelias /opt/pelias/docker/docker-compose.yml

# Download Who's on First data
if [ -d "/opt/pelias/docker/data/whosonfirst/sqlite" ] && [ "$(find /opt/pelias/docker/data/whosonfirst/sqlite -type f -name '*.db' 2>/dev/null | wc -l)" -gt 0 ]; then
    echo -e "${BLUE}Who's on First data already downloaded (skipping)${NC}"
    du -sh /opt/pelias/docker/data/whosonfirst/ | awk '{print "  Current data size: " $1}'
else
    echo -e "${BLUE}Downloading Who's on First data (this will take ~30 minutes and use ~70GB)...${NC}"
    su - pelias -c "cd /opt/pelias/docker && ./pelias download wof"
fi

# Create Pelias index
if curl -s -o /dev/null -w "%{http_code}" "http://localhost:9200/pelias" | grep -q "200"; then
    echo -e "${BLUE}Pelias index already exists (skipping creation)${NC}"
else
    echo -e "${BLUE}Creating Pelias index in Elasticsearch...${NC}"
    su - pelias -c "cd /opt/pelias/docker && ./pelias elastic create"

    # Verify index was created successfully
    if curl -s -o /dev/null -w "%{http_code}" "http://localhost:9200/pelias" | grep -q "200"; then
        echo -e "${GREEN}Pelias index created successfully${NC}"
    else
        echo -e "${RED}Error: Failed to create Pelias index${NC}"
        exit 1
    fi
fi

# Import Who's on First data
DOC_COUNT=$(curl -s "http://localhost:9200/pelias/_count" | jq -r '.count // 0' 2>/dev/null || echo "0")
if [ "$DOC_COUNT" -gt 100000 ]; then
    echo -e "${BLUE}Who's on First data already imported ($DOC_COUNT documents, skipping)${NC}"
else
    echo -e "${BLUE}Importing Who's on First data (this will take ~20-30 minutes)...${NC}"
    su - pelias -c "cd /opt/pelias/docker && ./pelias import wof"
    echo -e "${GREEN}Who's on First data import complete${NC}"
fi

# Download and import OpenAddresses data (for forward geocoding)
if [ -n "$OPENADDRESSES_TOKEN" ]; then
    OA_DATA_DIR="/opt/pelias/docker/data/openaddresses"
    if [ -d "$OA_DATA_DIR" ] && [ "$(find "$OA_DATA_DIR" -type f -name '*.csv' 2>/dev/null | wc -l)" -gt 100 ]; then
        echo -e "${BLUE}OpenAddresses data already downloaded (skipping)${NC}"
        du -sh "$OA_DATA_DIR" | awk '{print "  Current data size: " $1}'
    else
        echo -e "${BLUE}Downloading OpenAddresses data (this will take 1-2 hours and use ~50GB)...${NC}"
        echo -e "${YELLOW}This enables forward geocoding (address → coordinates)${NC}"
        su - pelias -c "cd /opt/pelias/docker && ./pelias download oa"
    fi

    # Check if OpenAddresses data was successfully downloaded before importing
    OA_FILE_COUNT=$(find "$OA_DATA_DIR" -type f -name '*.csv' 2>/dev/null | wc -l)
    if [ "$OA_FILE_COUNT" -gt 100 ]; then
        # Check current document count - OpenAddresses adds millions of addresses
        CURRENT_DOC_COUNT=$(curl -s "http://localhost:9200/pelias/_count" | jq -r '.count // 0' 2>/dev/null || echo "0")
        if [ "$CURRENT_DOC_COUNT" -gt 1000000 ]; then
            echo -e "${BLUE}OpenAddresses data already imported ($CURRENT_DOC_COUNT documents, skipping)${NC}"
        else
            echo -e "${BLUE}Importing OpenAddresses data (this will take 2-4 hours)...${NC}"
            echo -e "${YELLOW}Importing ~600 million addresses globally${NC}"
            su - pelias -c "cd /opt/pelias/docker && ./pelias import oa"
            echo -e "${GREEN}OpenAddresses data import complete${NC}"
        fi
    else
        echo -e "${YELLOW}OpenAddresses data not downloaded, skipping import${NC}"
    fi
else
    echo -e "${YELLOW}Skipping OpenAddresses download/import (no token configured)${NC}"
    echo -e "${YELLOW}Forward geocoding will fall back to Nominatim/Google Maps${NC}"
fi

# Build Placeholder data (administrative area relationships)
# Uses ./pelias prepare placeholder which extracts WOF data and builds the sqlite database
PLACEHOLDER_DB="/opt/pelias/docker/data/placeholder/store.sqlite3"
if [ -f "$PLACEHOLDER_DB" ] && [ "$(stat -c%s "$PLACEHOLDER_DB" 2>/dev/null || echo 0)" -gt 1000000 ]; then
    echo -e "${BLUE}Placeholder data already built (skipping)${NC}"
    du -sh "$PLACEHOLDER_DB" | awk '{print "  Database size: " $1}'
else
    echo -e "${BLUE}Building Placeholder database from Who's on First data...${NC}"
    echo -e "${YELLOW}This may take 5-10 minutes...${NC}"
    rm -f "$PLACEHOLDER_DB"  # Remove empty/corrupt database if present
    cd /opt/pelias/docker && ./pelias prepare placeholder
    echo -e "${GREEN}Placeholder database built${NC}"
fi

# Clone and install Pelias API
if [ ! -d /opt/pelias/api/.git ]; then
    echo -e "${BLUE}Cloning Pelias API repository...${NC}"
    sudo -u pelias git clone https://github.com/pelias/api.git /opt/pelias/api
    cd /opt/pelias/api
    sudo -u pelias npm install --production
else
    echo -e "${BLUE}Pelias API already exists${NC}"
fi

# Clone and install Pelias PIP service
if [ ! -d /opt/pelias/pip/.git ]; then
    echo -e "${BLUE}Cloning Pelias PIP service repository...${NC}"
    sudo -u pelias git clone https://github.com/pelias/pip-service.git /opt/pelias/pip
    cd /opt/pelias/pip
    sudo -u pelias npm install --production
else
    echo -e "${BLUE}Pelias PIP service already exists${NC}"
fi

# Copy pelias.json to API and PIP directories
cp /opt/pelias/docker/pelias.json /opt/pelias/api/pelias.json
cp /opt/pelias/docker/pelias.json /opt/pelias/pip/pelias.json
chown pelias:pelias /opt/pelias/api/pelias.json /opt/pelias/pip/pelias.json

# Update pelias.json for production services
# - Use localhost instead of Docker bridge IP
# - Use absolute path for whosonfirst data instead of Docker volume path
sed -i 's/"host": "172.17.0.1"/"host": "127.0.0.1"/g' /opt/pelias/api/pelias.json
sed -i 's/"host": "172.17.0.1"/"host": "127.0.0.1"/g' /opt/pelias/pip/pelias.json
sed -i 's|"datapath": "/data/whosonfirst"|"datapath": "/opt/pelias/docker/data/whosonfirst"|g' /opt/pelias/api/pelias.json
sed -i 's|"datapath": "/data/whosonfirst"|"datapath": "/opt/pelias/docker/data/whosonfirst"|g' /opt/pelias/pip/pelias.json

# Install Pelias systemd service files
echo -e "${BLUE}Installing Pelias systemd service files...${NC}"
PELIAS_SERVICES=("pelias-pip" "pelias-api" "pelias-libpostal" "pelias-placeholder")
for service in "${PELIAS_SERVICES[@]}"; do
    SERVICE_SOURCE="$REPO_ROOT/infrastructure/systemd/${service}.service"
    if [ -f "$SERVICE_SOURCE" ]; then
        cp "$SERVICE_SOURCE" "/etc/systemd/system/${service}.service"
        echo "  Installed ${service}.service"
    else
        echo -e "${RED}Error: $SERVICE_SOURCE not found${NC}"
        exit 1
    fi
done

# Pull Docker images for Libpostal and Placeholder
echo -e "${BLUE}Pulling Pelias Docker images...${NC}"
docker pull pelias/libpostal-service
docker pull pelias/placeholder

# Enable and start services
echo -e "${BLUE}Starting Pelias services...${NC}"
systemctl daemon-reload
systemctl enable pelias-pip.service
systemctl enable pelias-libpostal.service
systemctl enable pelias-placeholder.service
systemctl enable pelias-api.service
systemctl start pelias-pip.service
systemctl start pelias-libpostal.service
systemctl start pelias-placeholder.service
systemctl start pelias-api.service

# Wait for services to be ready
echo -e "${BLUE}Waiting for Pelias services to start...${NC}"
sleep 10

# Test the services
echo -e "${BLUE}Testing Pelias services...${NC}"

# Test PIP service
if curl -s http://localhost:4200/health > /dev/null 2>&1; then
    echo -e "${GREEN}Pelias PIP service is running${NC}"
else
    echo -e "${YELLOW}Warning: PIP service health check failed (may still be loading data)${NC}"
fi

# Test Libpostal service
if curl -s -X POST http://localhost:4400/parse -d '{"address": "123 Main St, New York, NY"}' | jq -e '.' > /dev/null 2>&1; then
    echo -e "${GREEN}Pelias Libpostal service is running${NC}"
else
    echo -e "${YELLOW}Warning: Libpostal service health check failed (may still be starting)${NC}"
    echo -e "${YELLOW}Check status with: journalctl -u pelias-libpostal -f${NC}"
fi

# Test Placeholder service
if curl -s http://localhost:4100/demo > /dev/null 2>&1; then
    echo -e "${GREEN}Pelias Placeholder service is running${NC}"
else
    echo -e "${YELLOW}Warning: Placeholder service health check failed (may need data build)${NC}"
    echo -e "${YELLOW}Check status with: journalctl -u pelias-placeholder -f${NC}"
fi

# Test API reverse geocoding
if curl -s 'http://localhost:4000/v1/reverse?point.lat=40.7484&point.lon=-73.9857' | jq -e '.features' > /dev/null 2>&1; then
    echo -e "${GREEN}Pelias API reverse geocoding is working${NC}"
else
    echo -e "${YELLOW}Warning: API reverse geocoding test failed (PIP may still be loading data)${NC}"
    echo -e "${YELLOW}Check status with: journalctl -u pelias-pip -f${NC}"
fi

# Test API forward geocoding (if OpenAddresses data is loaded)
if [ -n "$OPENADDRESSES_TOKEN" ]; then
    if curl -s 'http://localhost:4000/v1/search?text=1600+Pennsylvania+Avenue,+Washington+DC' | jq -e '.features[0]' > /dev/null 2>&1; then
        echo -e "${GREEN}Pelias API forward geocoding is working${NC}"
    else
        echo -e "${YELLOW}Warning: API forward geocoding test returned no results${NC}"
        echo -e "${YELLOW}This is normal if OpenAddresses data hasn't been imported yet${NC}"
    fi
fi

# Install Caddy
echo -e "${BLUE}Installing Caddy web server...${NC}"

# Add Caddy GPG key (Cloudsmith expects it in /usr/share/keyrings/)
mkdir -p /usr/share/keyrings
if [ ! -f /usr/share/keyrings/caddy-stable-archive-keyring.gpg ]; then
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | \
        gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
fi

# Add Caddy repository (uses signed-by pointing to /usr/share/keyrings/)
if [ ! -f /etc/apt/sources.list.d/caddy-stable.list ]; then
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | \
        tee /etc/apt/sources.list.d/caddy-stable.list
fi

apt-get update
apt-get install -y caddy

echo -e "${GREEN}Caddy installed successfully${NC}"

# Configure Caddy
echo -e "${BLUE}Configuring Caddy web server...${NC}"

# Create Caddy log directory
mkdir -p /var/log/caddy
chown caddy:caddy /var/log/caddy

# Create SOAR Caddy configuration directory
mkdir -p /etc/soar/caddy
chown root:root /etc/soar/caddy
chmod 755 /etc/soar/caddy

# Install Pelias Caddy site configs (both production and staging)
PELIAS_CADDY_SITES=("pelias.glider.flights" "pelias.staging.glider.flights")

echo "Installing Pelias Caddy site configs..."
for site in "${PELIAS_CADDY_SITES[@]}"; do
    SITE_SOURCE="$REPO_ROOT/infrastructure/caddy/${site}.conf"
    SITE_DEST="/etc/soar/caddy/${site}.conf"

    if [ -f "$SITE_SOURCE" ]; then
        cp "$SITE_SOURCE" "$SITE_DEST"
        chown root:root "$SITE_DEST"
        chmod 644 "$SITE_DEST"
        echo "  Installed ${site}.conf"
    else
        echo -e "${YELLOW}Warning: $SITE_SOURCE not found - skipping${NC}"
    fi
done

# Ensure main Caddyfile imports SOAR configs
MAIN_CADDYFILE="/etc/caddy/Caddyfile"
IMPORT_LINE="import /etc/soar/caddy/*"

# Create main Caddyfile if it doesn't exist
if [ ! -f "$MAIN_CADDYFILE" ]; then
    echo -e "${YELLOW}Creating main Caddyfile with import directive...${NC}"
    echo "# Main Caddyfile - imports SOAR site configurations" | tee "$MAIN_CADDYFILE" > /dev/null
    echo "$IMPORT_LINE" | tee -a "$MAIN_CADDYFILE" > /dev/null
    chown root:root "$MAIN_CADDYFILE"
    chmod 644 "$MAIN_CADDYFILE"
    echo "Created $MAIN_CADDYFILE with import directive"
else
    # Check if import directive already exists
    if ! grep -qF "$IMPORT_LINE" "$MAIN_CADDYFILE"; then
        echo -e "${YELLOW}Adding import directive to existing Caddyfile...${NC}"
        # Backup existing Caddyfile
        cp "$MAIN_CADDYFILE" "$MAIN_CADDYFILE.backup.$(date +%Y%m%d_%H%M%S)"
        # Add import directive at the end
        echo "" | tee -a "$MAIN_CADDYFILE" > /dev/null
        echo "# Import SOAR site configurations" | tee -a "$MAIN_CADDYFILE" > /dev/null
        echo "$IMPORT_LINE" | tee -a "$MAIN_CADDYFILE" > /dev/null
        echo "Added import directive to $MAIN_CADDYFILE (backup created)"
    else
        echo -e "${BLUE}Import directive already exists in $MAIN_CADDYFILE${NC}"
    fi
fi

# Validate Caddyfile syntax
if command -v caddy &> /dev/null; then
    if caddy validate --config "$MAIN_CADDYFILE" 2>/dev/null; then
        echo -e "${GREEN}Caddyfile validation passed${NC}"
    else
        echo -e "${YELLOW}Warning: Caddyfile validation failed. Check configuration manually.${NC}"
    fi
fi

# Reload Caddy to pick up new configuration
systemctl reload caddy

echo -e "${GREEN}Caddy configured for Pelias with ${#PELIAS_CADDY_SITES[@]} site(s)${NC}"

echo ""
echo -e "${GREEN}======================================${NC}"
echo -e "${GREEN}Pelias geocoding server setup complete!${NC}"
echo -e "${GREEN}======================================${NC}"
echo ""
echo -e "${BLUE}Services:${NC}"
echo -e "  - Elasticsearch: http://localhost:9200"
echo -e "  - Pelias API: http://localhost:4000"
echo -e "  - Pelias PIP: http://localhost:4200 (reverse geocoding)"
echo -e "  - Pelias Libpostal: http://localhost:4400 (address parsing)"
echo -e "  - Pelias Placeholder: http://localhost:4100 (admin lookups)"
echo -e "  - Caddy reverse proxy: http://localhost (configured)"
echo ""
echo -e "${BLUE}Public URLs (via Caddy):${NC}"
echo -e "  - Production: https://pelias.glider.flights"
echo -e "  - Staging: https://pelias.staging.glider.flights"
echo ""
echo -e "${BLUE}Service management:${NC}"
echo -e "  sudo systemctl status pelias-api"
echo -e "  sudo systemctl status pelias-pip"
echo -e "  sudo systemctl status pelias-libpostal"
echo -e "  sudo systemctl status pelias-placeholder"
echo -e "  sudo systemctl status elasticsearch"
echo -e "  sudo systemctl status caddy"
echo ""
echo -e "${BLUE}View logs:${NC}"
echo -e "  sudo journalctl -u pelias-api -f"
echo -e "  sudo journalctl -u pelias-pip -f"
echo -e "  sudo journalctl -u pelias-libpostal -f"
echo -e "  sudo journalctl -u pelias-placeholder -f"
echo ""
echo -e "${BLUE}Test reverse geocoding (coordinates → address):${NC}"
echo -e "  curl 'http://localhost:4000/v1/reverse?point.lat=40.7484&point.lon=-73.9857'"
echo ""
echo -e "${BLUE}Test forward geocoding (address → coordinates):${NC}"
echo -e "  curl 'http://localhost:4000/v1/search?text=1600+Pennsylvania+Avenue,+Washington+DC'"
echo ""
if [ -n "$OPENADDRESSES_TOKEN" ]; then
    echo -e "${GREEN}OpenAddresses token configured - forward geocoding enabled${NC}"
else
    echo -e "${YELLOW}OpenAddresses token NOT configured${NC}"
    echo -e "${YELLOW}To enable forward geocoding:${NC}"
    echo -e "${YELLOW}  1. Register at https://openaddresses.io to get a token${NC}"
    echo -e "${YELLOW}  2. Add OPENADDRESSES_TOKEN=... to /etc/soar/env-production${NC}"
    echo -e "${YELLOW}  3. Re-run this script to download OpenAddresses data${NC}"
fi
echo ""
echo -e "${YELLOW}Note: PIP service may take 10-20 minutes to load all locality data into memory.${NC}"
echo -e "${YELLOW}Monitor with: journalctl -u pelias-pip -f${NC}"
echo ""
echo -e "${YELLOW}Next steps:${NC}"
echo -e "  1. Configure DNS to point pelias.glider.flights and pelias.staging.glider.flights to this server"
echo -e "  2. Set PELIAS_BASE_URL in SOAR backend environment configuration"
echo -e "  3. Restart SOAR services to use Pelias geocoding"
echo ""

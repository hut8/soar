#!/bin/bash
set -e

# SOAR Release Script
# Fully automated version bumping and release process
#
# This script respects branch protection on main by:
# 1. Creating a release branch from main
# 2. Bumping versions and committing to the release branch
# 3. Pushing the release branch and creating a PR with auto-merge enabled
# 4. Waiting for CI checks to pass and PR to auto-merge
# 5. Automatically creating and pushing the git tag after merge
# 6. GitHub Actions then builds and publishes the release
#
# The entire process is automated - just run the script and wait!
#
# Usage:
#   ./release patch        # 0.1.0 → 0.1.1 (fully automated)
#   ./release minor        # 0.1.0 → 0.2.0 (fully automated)
#   ./release major        # 0.1.0 → 1.0.0 (fully automated)
#   ./release 1.2.3        # Set explicit version (fully automated)
#   ./release patch --dry-run  # Test without pushing

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Parse arguments
BUMP_TYPE="$1"
DRY_RUN=false

if [ -z "$BUMP_TYPE" ]; then
    echo -e "${RED}Error: Version bump type required${NC}"
    echo "Usage: ./release [patch|minor|major|VERSION] [--dry-run]"
    exit 1
fi

if [ "$2" = "--dry-run" ] || [ "$BUMP_TYPE" = "--dry-run" ]; then
    DRY_RUN=true
    echo -e "${YELLOW}DRY RUN MODE - No changes will be pushed${NC}\n"
fi

# Validate we're on main branch and it's clean
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
    echo -e "${RED}Error: Must be on main branch (currently on: $CURRENT_BRANCH)${NC}"
    exit 1
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
    echo -e "${RED}Error: Uncommitted changes detected. Please commit or stash first.${NC}"
    git status --short
    exit 1
fi

# Pull latest changes
echo -e "${BLUE}Pulling latest changes...${NC}"
git pull

# Get current version from Cargo.toml
CURRENT_VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
echo -e "${BLUE}Current version: ${GREEN}$CURRENT_VERSION${NC}"

# Calculate new version
if [[ "$BUMP_TYPE" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    # Explicit version provided
    NEW_VERSION="$BUMP_TYPE"
else
    # Parse current version
    IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

    case "$BUMP_TYPE" in
        major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
        minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
        patch)
            PATCH=$((PATCH + 1))
            ;;
        *)
            echo -e "${RED}Error: Invalid bump type '$BUMP_TYPE'${NC}"
            echo "Must be: patch, minor, major, or explicit version (e.g., 1.2.3)"
            exit 1
            ;;
    esac

    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
fi

echo -e "${BLUE}New version: ${GREEN}$NEW_VERSION${NC}\n"

# Update Cargo.toml
echo -e "${BLUE}Updating Cargo.toml...${NC}"
sed -i.bak "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
rm Cargo.toml.bak

# Update web/package.json
echo -e "${BLUE}Updating web/package.json...${NC}"
cd web
npm version "$NEW_VERSION" --no-git-tag-version
cd ..

# Update Cargo.lock
echo -e "${BLUE}Updating Cargo.lock...${NC}"
cargo check --quiet

# Show changes
echo -e "\n${BLUE}Changes to be committed:${NC}"
git diff --stat

# Create release branch
RELEASE_BRANCH="release/v$NEW_VERSION"
echo -e "\n${BLUE}Creating release branch: ${GREEN}$RELEASE_BRANCH${NC}"
git checkout -b "$RELEASE_BRANCH"

# Commit changes
echo -e "${BLUE}Committing version bump...${NC}"
git add Cargo.toml Cargo.lock web/package.json web/package-lock.json
git commit -m "chore: bump version to $NEW_VERSION"

# Push changes and create PR
if [ "$DRY_RUN" = true ]; then
    echo -e "\n${YELLOW}DRY RUN: Skipping push and PR creation${NC}"
    echo "Would have pushed:"
    echo "  - Branch: $RELEASE_BRANCH"
    echo "  - Commit: $(git log -1 --oneline)"
    echo -e "\n${YELLOW}To undo dry run changes:${NC}"
    echo "  git checkout main"
    echo "  git branch -D $RELEASE_BRANCH"
else
    echo -e "${BLUE}Pushing release branch...${NC}"
    git push -u origin "$RELEASE_BRANCH"

    # Create PR using gh CLI with auto-merge enabled
    echo -e "${BLUE}Creating pull request with auto-merge...${NC}"
    PR_URL=$(gh pr create \
        --title "chore: Release v$NEW_VERSION" \
        --body "$(cat <<EOF
## Release v$NEW_VERSION

This PR bumps the version to **v$NEW_VERSION** in preparation for release.

### Changes
- Updated version in \`Cargo.toml\`
- Updated version in \`web/package.json\`
- Updated \`Cargo.lock\`

### Automated Release Process
This PR is configured to auto-merge when all checks pass. After merge, the release script will automatically create and push the git tag.
EOF
)" \
        --base main \
        --head "$RELEASE_BRANCH")

    echo -e "${GREEN}✓ Release PR created: $PR_URL${NC}"

    # Extract PR number from URL
    PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

    # Enable auto-merge
    echo -e "${BLUE}Enabling auto-merge...${NC}"
    gh pr merge "$PR_NUMBER" --auto --merge

    echo -e "${YELLOW}Waiting for CI checks to pass and PR to merge...${NC}"
    echo -e "${BLUE}This may take a few minutes. You can watch progress at: $PR_URL${NC}\n"

    # Poll for PR merge status
    POLL_INTERVAL=10
    MAX_WAIT=1800  # 30 minutes max
    ELAPSED=0

    while [ $ELAPSED -lt $MAX_WAIT ]; do
        PR_STATE=$(gh pr view "$PR_NUMBER" --json state --jq .state)

        if [ "$PR_STATE" = "MERGED" ]; then
            echo -e "\n${GREEN}✓ PR merged successfully!${NC}"
            break
        elif [ "$PR_STATE" = "CLOSED" ]; then
            echo -e "\n${RED}Error: PR was closed without merging${NC}"
            exit 1
        fi

        # Show status update every minute
        if [ $((ELAPSED % 60)) -eq 0 ]; then
            CHECK_STATUS=$(gh pr checks "$PR_NUMBER" --json state --jq '.[].state' | sort | uniq -c)
            echo -e "${BLUE}[$((ELAPSED / 60))m] Waiting for checks... Current status:${NC}"
            echo "$CHECK_STATUS" | sed 's/^/  /'
        fi

        sleep $POLL_INTERVAL
        ELAPSED=$((ELAPSED + POLL_INTERVAL))
    done

    if [ $ELAPSED -ge $MAX_WAIT ]; then
        echo -e "\n${YELLOW}Timeout waiting for PR to merge${NC}"
        echo -e "${YELLOW}PR is still open at: $PR_URL${NC}"
        echo -e "${YELLOW}You can manually create the tag after merge with:${NC}"
        echo -e "  ${GREEN}git checkout main && git pull${NC}"
        echo -e "  ${GREEN}git tag -a v$NEW_VERSION -m \"Release v$NEW_VERSION\"${NC}"
        echo -e "  ${GREEN}git push origin v$NEW_VERSION${NC}"
        exit 1
    fi

    # PR merged, now create and push the tag
    TAG="v$NEW_VERSION"
    echo -e "\n${BLUE}Switching to main and pulling latest changes...${NC}"
    git checkout main
    git pull

    echo -e "${BLUE}Creating and pushing release tag: ${GREEN}$TAG${NC}"
    git tag -a "$TAG" -m "Release $TAG"
    git push origin "$TAG"

    echo -e "\n${GREEN}✓ Release $TAG completed successfully!${NC}"
    echo -e "${BLUE}GitHub Actions will now build and publish the release${NC}"
    REPO_URL=$(git remote get-url origin | sed 's/.*github.com[:/]\(.*\)\.git/\1/')
    echo -e "${BLUE}Watch progress at: https://github.com/$REPO_URL/actions${NC}"
    echo -e "${BLUE}Release page: https://github.com/$REPO_URL/releases/tag/$TAG${NC}"
fi

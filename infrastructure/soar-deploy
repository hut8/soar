#!/bin/bash
#
# SOAR Deployment Script
#
# This script is executed with sudo privileges to deploy SOAR updates.
# It must be installed at /usr/local/bin/soar-deploy with permissions 755.
#
# Usage:
#   sudo /usr/local/bin/soar-deploy [production|staging] /tmp/soar/deploy/YYYYMMDDHHMMSS
#   sudo /usr/local/bin/soar-deploy /tmp/soar/deploy/YYYYMMDDHHMMSS  (defaults to production)
#
# The deployment directory should contain:
#   - soar (the binary)
#   - soar-deploy (this script - for self-update)
#   - *.service files (production) or *-staging.service files (staging)
#   - *.timer files (production) or *-staging.timer files (staging)
#   - *.target files (soar.target or soar-staging.target)
#   - prometheus-jobs/ directory (optional, contains Prometheus job configs)
#   - grafana-provisioning/ directory (optional, contains Grafana provisioning configs)
#   - grafana-dashboard-*.json files (optional, Grafana dashboards)
#
# Self-Update:
#   This script will automatically update itself if the version in the deployment
#   directory differs from /usr/local/bin/soar-deploy, then re-execute with the
#   same arguments to ensure the latest deployment logic is used.
#

set -e
set -u
set -o pipefail

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Parse arguments: environment and deploy directory
# Supports both: "soar-deploy staging /path" and "soar-deploy /path" (defaults to production)
if [ $# -eq 2 ]; then
    ENVIRONMENT="$1"
    DEPLOY_DIR="$2"
elif [ $# -eq 1 ]; then
    ENVIRONMENT="production"
    DEPLOY_DIR="$1"
else
    log_error "Usage: $0 [production|staging] /tmp/soar/deploy/YYYYMMDDHHMMSS"
    log_error "   or: $0 /tmp/soar/deploy/YYYYMMDDHHMMSS  (defaults to production)"
    exit 1
fi

# Validate environment
if [ "$ENVIRONMENT" != "production" ] && [ "$ENVIRONMENT" != "staging" ]; then
    log_error "Invalid environment: $ENVIRONMENT (must be 'production' or 'staging')"
    exit 1
fi

# Verify deployment directory exists
if [ ! -d "$DEPLOY_DIR" ]; then
    log_error "Deployment directory does not exist: $DEPLOY_DIR"
    exit 1
fi

log_info "Starting SOAR deployment for $ENVIRONMENT from: $DEPLOY_DIR"

# Self-update: Check if deployment script itself has changed
if [ -f "$DEPLOY_DIR/soar-deploy" ]; then
    if ! diff -q "$0" "$DEPLOY_DIR/soar-deploy" >/dev/null 2>&1; then
        log_warn "Deployment script has changed - updating /usr/local/bin/soar-deploy and re-executing..."

        # Install updated deployment script
        install -m 755 -o root -g root "$DEPLOY_DIR/soar-deploy" /usr/local/bin/soar-deploy

        log_info "Deployment script updated, re-executing with same arguments..."
        # Re-exec the updated script with original arguments
        exec /usr/local/bin/soar-deploy "$@"
    else
        log_info "Deployment script is up-to-date"
    fi
else
    log_warn "No soar-deploy found in deployment directory, skipping self-update check"
fi

# Set environment-specific variables
if [ "$ENVIRONMENT" = "staging" ]; then
    SERVICE_SUFFIX="-staging"
    ENV_FILE="/etc/soar/env-staging"
    BINARY_PATH="/usr/local/bin/soar-staging"
    BACKUP_DIR="/home/soar/backups/staging"
else
    SERVICE_SUFFIX=""
    ENV_FILE="/etc/soar/env"
    BINARY_PATH="/usr/local/bin/soar"
    BACKUP_DIR="/home/soar/backups/production"
fi

log_info "Environment: $ENVIRONMENT"
log_info "Service suffix: '$SERVICE_SUFFIX'"
log_info "Environment file: $ENV_FILE"
log_info "Binary path: $BINARY_PATH"

# Verify binary exists
if [ ! -f "$DEPLOY_DIR/soar" ]; then
    log_error "Binary not found in deployment directory: $DEPLOY_DIR/soar"
    exit 1
fi

# Define services and timers based on environment
# Active services that should be enabled and started
ACTIVE_SERVICES=(
    "soar-ingest-ogn${SERVICE_SUFFIX}.service"
    "soar-run${SERVICE_SUFFIX}.service"
    "soar-web${SERVICE_SUFFIX}.service"
)

# Timer-invoked services (only installed, not enabled or started)
# Skip backup services for staging environment
# NOTE: soar-ingest-adsb.service is disabled by default until ready for production
if [ "$ENVIRONMENT" = "staging" ]; then
    TIMER_SERVICES=(
        "soar-pull-data${SERVICE_SUFFIX}.service"
        "soar-sitemap${SERVICE_SUFFIX}.service"
        "soar-archive${SERVICE_SUFFIX}.service"
        "partman-maintenance${SERVICE_SUFFIX}.service"
        "soar-ingest-adsb${SERVICE_SUFFIX}.service"
    )
    TIMERS=(
        "soar-pull-data${SERVICE_SUFFIX}.timer"
        "soar-sitemap${SERVICE_SUFFIX}.timer"
        "soar-archive${SERVICE_SUFFIX}.timer"
        "partman-maintenance${SERVICE_SUFFIX}.timer"
    )
else
    TIMER_SERVICES=(
        "soar-pull-data${SERVICE_SUFFIX}.service"
        "soar-sitemap${SERVICE_SUFFIX}.service"
        "soar-archive${SERVICE_SUFFIX}.service"
        "soar-backup-base${SERVICE_SUFFIX}.service"
        "soar-backup-verify${SERVICE_SUFFIX}.service"
        "partman-maintenance${SERVICE_SUFFIX}.service"
        "soar-ingest-adsb${SERVICE_SUFFIX}.service"
    )
    TIMERS=(
        "soar-pull-data${SERVICE_SUFFIX}.timer"
        "soar-sitemap${SERVICE_SUFFIX}.timer"
        "soar-archive${SERVICE_SUFFIX}.timer"
        "soar-backup-base${SERVICE_SUFFIX}.timer"
        "soar-backup-verify${SERVICE_SUFFIX}.timer"
        "partman-maintenance${SERVICE_SUFFIX}.timer"
    )
fi

# All services (for stopping and installing)
ALL_SERVICES=("${ACTIVE_SERVICES[@]}" "${TIMER_SERVICES[@]}")

# Create temporary binary directory with timestamp
TIMESTAMP=$(date +%s)
TEMP_BIN_DIR="/var/soar/bin"
TEMP_BIN_PATH="$TEMP_BIN_DIR/soar-$TIMESTAMP"

log_info "Creating temporary binary directory: $TEMP_BIN_DIR"
mkdir -p "$TEMP_BIN_DIR"
chown soar:soar "$TEMP_BIN_DIR"

# Deploy new binary to temporary location first (avoids "text file busy")
log_info "Deploying new binary to temporary location: $TEMP_BIN_PATH"
install -m 755 -o soar -g soar "$DEPLOY_DIR/soar" "$TEMP_BIN_PATH"
log_info "Binary deployed to temporary location"

# Stop soar-run service only (for migrations, keep others running)
log_info "Stopping soar-run${SERVICE_SUFFIX} service for migrations..."
if systemctl is-active --quiet "soar-run${SERVICE_SUFFIX}.service"; then
    systemctl stop "soar-run${SERVICE_SUFFIX}.service" || log_warn "Failed to stop soar-run${SERVICE_SUFFIX}.service"
    log_info "soar-run${SERVICE_SUFFIX}.service stopped"
else
    log_info "soar-run${SERVICE_SUFFIX}.service is not running"
fi

# Wait for service to fully terminate
sleep 2

# Check current migration status before running migrations
log_info "Checking current database migration status..."
sudo -u soar bash -c "set -a; source $ENV_FILE; set +a; psql \"\$DATABASE_URL\" -c \"SELECT version FROM __diesel_schema_migrations ORDER BY version DESC LIMIT 5;\"" 2>/dev/null || log_warn "Could not query migration status"

# Run database migrations from temporary binary (not /usr/local/bin to avoid "text file busy")
log_info "Running database migrations from temporary binary..."
if sudo -u soar bash -c "set -a; source $ENV_FILE; set +a; exec '$TEMP_BIN_PATH' migrate"; then
    log_info "Database migrations completed successfully"
else
    log_error "Database migrations failed"
    log_error "Database may be in a partially migrated state"
    log_error "DO NOT restart services - manual intervention required"
    log_info "Cleaning up temporary binary: $TEMP_BIN_PATH"
    rm -f "$TEMP_BIN_PATH"
    log_error "Deployment aborted. soar-run${SERVICE_SUFFIX}.service remains stopped for safety."
    log_info "To investigate:"
    log_info "  1. Check migration logs above"
    log_info "  2. Verify database state manually"
    log_info "  3. Fix any issues before attempting to restart services"
    exit 1
fi

# Now stop ALL remaining services (migrations are complete)
log_info "Stopping remaining SOAR services..."
for service in "${ALL_SERVICES[@]}"; do
    # Skip soar-run since we already stopped it
    if [ "$service" = "soar-run${SERVICE_SUFFIX}.service" ]; then
        continue
    fi

    if systemctl is-active --quiet "$service"; then
        log_info "Stopping $service..."
        systemctl stop "$service" || log_warn "Failed to stop $service"
    else
        log_info "$service is not running"
    fi
done

# Note: We intentionally do NOT stop timers during deployment
# Timers pick up configuration changes via daemon-reload without needing to be stopped/started
# Stopping and restarting timers with Persistent=yes can trigger immediate runs
log_info "Skipping timer stop (timers will continue on their schedule)"

# Wait for services to fully terminate
log_info "Waiting for services to fully terminate..."
sleep 3

# Backup current binary
mkdir -p "$BACKUP_DIR"
chown soar:soar "$BACKUP_DIR"

if [ -f "$BINARY_PATH" ]; then
    BACKUP_FILE="$BACKUP_DIR/soar.backup.$(date +%s)"
    log_info "Backing up current binary to $BACKUP_FILE..."
    cp "$BINARY_PATH" "$BACKUP_FILE"
    chown soar:soar "$BACKUP_FILE"
else
    log_warn "No existing binary to backup at $BINARY_PATH"
fi

# Install new binary
log_info "Installing new binary to $BINARY_PATH..."
install -m 755 -o root -g root "$TEMP_BIN_PATH" "$BINARY_PATH"
log_info "Binary installed successfully at $BINARY_PATH"

# Clean up temporary binary
log_info "Cleaning up temporary binary: $TEMP_BIN_PATH"
rm -f "$TEMP_BIN_PATH"

# Install service files
log_info "Installing service files..."
for service in "${ALL_SERVICES[@]}"; do
    if [ -f "$DEPLOY_DIR/$service" ]; then
        log_info "Installing $service..."
        cp "$DEPLOY_DIR/$service" /etc/systemd/system/
        chmod 644 "/etc/systemd/system/$service"
    else
        log_warn "$service not found in deployment directory, skipping"
    fi
done

# Install timer files
log_info "Installing timer files..."
for timer in "${TIMERS[@]}"; do
    if [ -f "$DEPLOY_DIR/$timer" ]; then
        log_info "Installing $timer..."
        cp "$DEPLOY_DIR/$timer" /etc/systemd/system/
        chmod 644 "/etc/systemd/system/$timer"
    else
        log_warn "$timer not found in deployment directory, skipping"
    fi
done

# Install target file
TARGET_FILE="soar${SERVICE_SUFFIX}.target"
if [ -f "$DEPLOY_DIR/$TARGET_FILE" ]; then
    log_info "Installing $TARGET_FILE..."
    cp "$DEPLOY_DIR/$TARGET_FILE" /etc/systemd/system/
    chmod 644 "/etc/systemd/system/$TARGET_FILE"
else
    log_warn "$TARGET_FILE not found in deployment directory, skipping"
fi

# Install backup scripts
if [ -d "$DEPLOY_DIR/scripts/backup" ]; then
    log_info "Installing backup scripts to /usr/local/bin/..."

    # Install each backup script with soar- prefix
    for script in wal-archive base-backup backup-verify restore; do
        if [ -f "$DEPLOY_DIR/scripts/backup/$script" ]; then
            log_info "Installing soar-$script..."
            install -m 755 -o root -g root "$DEPLOY_DIR/scripts/backup/$script" "/usr/local/bin/soar-$script"
        else
            log_warn "scripts/backup/$script not found, skipping"
        fi
    done

    log_info "Backup scripts installed successfully"
else
    log_warn "scripts/backup directory not found in deployment, skipping backup script installation"
fi

# Install Prometheus job configuration files
PROMETHEUS_NEEDS_RELOAD=false
if [ -d "$DEPLOY_DIR/prometheus-jobs" ]; then
    log_info "Installing Prometheus job configuration files..."
    mkdir -p /etc/prometheus/jobs
    cp "$DEPLOY_DIR/prometheus-jobs"/*.yml /etc/prometheus/jobs/
    chmod 644 /etc/prometheus/jobs/*.yml

    # Set ownership to prometheus user if it exists
    if id "prometheus" &>/dev/null; then
        chown -R prometheus:prometheus /etc/prometheus/jobs
        log_info "Prometheus job files installed and ownership set to prometheus:prometheus"
        PROMETHEUS_NEEDS_RELOAD=true
    else
        log_warn "prometheus user not found, skipping ownership change"
        log_info "Prometheus job files installed"
    fi
else
    log_warn "prometheus-jobs directory not found in deployment, skipping Prometheus configuration"
fi

# Reload Prometheus if job configurations were updated
if [ "$PROMETHEUS_NEEDS_RELOAD" = true ]; then
    if systemctl is-active --quiet prometheus; then
        log_info "Reloading Prometheus to load new scrape configurations..."
        systemctl reload prometheus || log_warn "Failed to reload Prometheus"
        log_info "Prometheus reloaded successfully"
    else
        log_warn "Prometheus is not running, skipping reload"
    fi
fi

# Install Grafana dashboards and provisioning configuration
GRAFANA_NEEDS_RESTART=false

if [ -d "$DEPLOY_DIR/grafana-provisioning" ]; then
    log_info "Installing Grafana provisioning configuration..."
    mkdir -p /etc/grafana/provisioning/dashboards
    cp -r "$DEPLOY_DIR/grafana-provisioning/dashboards"/*.yml /etc/grafana/provisioning/dashboards/
    chmod 644 /etc/grafana/provisioning/dashboards/*.yml

    # Set ownership to grafana user if it exists
    if id "grafana" &>/dev/null; then
        chown -R grafana:grafana /etc/grafana/provisioning/dashboards
        log_info "Grafana provisioning configuration installed"
        GRAFANA_NEEDS_RESTART=true
    else
        log_warn "grafana user not found, skipping ownership change"
    fi
fi

# Install Grafana dashboard JSON files
DASHBOARD_COUNT=0
if compgen -G "$DEPLOY_DIR/grafana-dashboard-*.json" > /dev/null; then
    log_info "Installing Grafana dashboard files..."
    mkdir -p /etc/grafana/dashboards
    cp "$DEPLOY_DIR"/grafana-dashboard-*.json /etc/grafana/dashboards/
    chmod 644 /etc/grafana/dashboards/*.json

    # Set ownership to grafana user if it exists
    if id "grafana" &>/dev/null; then
        chown -R grafana:grafana /etc/grafana/dashboards
        DASHBOARD_COUNT=$(ls -1 "$DEPLOY_DIR"/grafana-dashboard-*.json | wc -l)
        log_info "Installed $DASHBOARD_COUNT Grafana dashboard(s)"
        GRAFANA_NEEDS_RESTART=true
    else
        log_warn "grafana user not found, skipping ownership change"
    fi
else
    log_warn "No Grafana dashboard files found in deployment, skipping dashboard installation"
fi

# Restart Grafana if dashboards or provisioning was updated
if [ "$GRAFANA_NEEDS_RESTART" = true ]; then
    if systemctl is-active --quiet grafana-server; then
        log_info "Restarting Grafana to load new dashboards..."
        systemctl restart grafana-server || log_warn "Failed to restart Grafana"
        log_info "Grafana restarted successfully"
    else
        log_warn "Grafana is not running, skipping restart"
    fi
fi

# Reload systemd daemon
log_info "Reloading systemd daemon..."
systemctl daemon-reload

# Enable target file
if [ -f "/etc/systemd/system/$TARGET_FILE" ]; then
    log_info "Enabling $TARGET_FILE..."
    systemctl enable "$TARGET_FILE" || log_warn "Failed to enable $TARGET_FILE"
fi

# Enable and start services - start ogn-ingest first, then others
log_info "Enabling and starting SOAR services..."

# Start soar-ingest-ogn first
if [ -f "/etc/systemd/system/soar-ingest-ogn${SERVICE_SUFFIX}.service" ]; then
    log_info "Enabling soar-ingest-ogn${SERVICE_SUFFIX}.service..."
    systemctl enable "soar-ingest-ogn${SERVICE_SUFFIX}.service" || log_warn "Failed to enable soar-ingest-ogn${SERVICE_SUFFIX}.service"

    log_info "Starting soar-ingest-ogn${SERVICE_SUFFIX}.service..."
    systemctl start "soar-ingest-ogn${SERVICE_SUFFIX}.service" || log_warn "Failed to start soar-ingest-ogn${SERVICE_SUFFIX}.service"

    # Give it a moment to initialize
    sleep 2
fi

# Start the rest of the active services
for service in "${ACTIVE_SERVICES[@]}"; do
    # Skip ogn-ingest since we already started it
    if [ "$service" = "soar-ingest-ogn${SERVICE_SUFFIX}.service" ]; then
        continue
    fi

    if [ -f "/etc/systemd/system/$service" ]; then
        log_info "Enabling $service..."
        systemctl enable "$service" || log_warn "Failed to enable $service"

        log_info "Starting $service..."
        systemctl start "$service" || log_warn "Failed to start $service"
    fi
done

# Timer-invoked services are installed but not enabled or started
log_info "Timer-invoked services (${TIMER_SERVICES[*]}) will only be invoked by their timers"

# Enable and start timers only if they're not already running
# Timers pick up configuration changes via daemon-reload without restart
log_info "Ensuring SOAR timers are enabled and active..."
for timer in "${TIMERS[@]}"; do
    if [ -f "/etc/systemd/system/$timer" ]; then
        # Enable timer for automatic start on boot
        systemctl enable "$timer" || log_warn "Failed to enable $timer"

        # Start timer only if it's not already active (never restart to avoid triggering Persistent logic)
        if ! systemctl is-active --quiet "$timer"; then
            log_info "Starting $timer (was not active)..."
            systemctl start "$timer" || log_warn "Failed to start $timer"
        else
            log_info "$timer is already active and will continue on schedule"
        fi
    fi
done

# Wait for services to start
log_info "Waiting for services to initialize..."
sleep 5

# Check service status
log_info "Checking service status..."
ALL_HEALTHY=true

for service in "${ACTIVE_SERVICES[@]}"; do
    if systemctl is-active --quiet "$service"; then
        log_info "$service: ${GREEN}ACTIVE${NC}"
    else
        log_error "$service: ${RED}FAILED${NC}"
        ALL_HEALTHY=false

        # Show recent logs for failed service
        log_info "Recent logs for $service:"
        journalctl -u "$service" --no-pager --lines=10 || true
    fi
done

# Check timer-invoked services are not running (they should be stopped)
for service in "${TIMER_SERVICES[@]}"; do
    if systemctl is-active --quiet "$service"; then
        log_warn "$service: ${YELLOW}RUNNING${NC} (should only run via timer)"
    else
        log_info "$service: ${GREEN}STOPPED${NC} (timer-invoked only)"
    fi
done

for timer in "${TIMERS[@]}"; do
    if systemctl is-enabled --quiet "$timer" 2>/dev/null; then
        if systemctl is-active --quiet "$timer"; then
            log_info "$timer: ${GREEN}ENABLED and ACTIVE${NC}"
        else
            log_info "$timer: ${GREEN}ENABLED${NC} (will activate on next boot or scheduled time)"
        fi
    else
        log_warn "$timer: ${YELLOW}NOT ENABLED${NC}"
    fi
done

# Show recent logs from all services
log_info "Recent logs from soar-run${SERVICE_SUFFIX}:"
journalctl -u "soar-run${SERVICE_SUFFIX}.service" --no-pager --lines=5 || true

log_info "Recent logs from soar-web${SERVICE_SUFFIX}:"
journalctl -u "soar-web${SERVICE_SUFFIX}.service" --no-pager --lines=5 || true

# Clean up old backups (keep last 5)
log_info "Cleaning up old backups in $BACKUP_DIR (keeping last 5)..."
ls -t "$BACKUP_DIR"/soar.backup.* 2>/dev/null | tail -n +6 | xargs rm -f || true

# Clean up old deployment directories (keep last 3)
log_info "Cleaning up old deployment directories (keeping last 3)..."
ls -td /tmp/soar/deploy/* 2>/dev/null | tail -n +4 | xargs rm -rf || true

if [ "$ALL_HEALTHY" = true ]; then
    log_info "${GREEN}Deployment completed successfully!${NC}"
    exit 0
else
    log_error "${RED}Deployment completed with errors. Some services failed to start.${NC}"
    exit 1
fi

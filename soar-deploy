#!/bin/bash
#
# SOAR Server-Side Deployment Script
# This script is meant to be installed at /usr/local/bin/soar-deploy on the production server
# It is called by the CI/CD pipeline with a deployment directory as an argument
#

set -e

# Configuration
BINARY_PATH="/usr/local/bin"
SERVICE_USER="soar"
SERVICE_GROUP="soar"
BINARY_NAME="soar"
DEPLOY_BASE="/var/soar"
LOGS_DIR="/var/soar/logs"
ARCHIVE_DIR="/var/soar/archive"
SITEMAP_DIR="/var/soar/sitemap"

# Services
RUN_SERVICE="soar-run"
WEB_SERVICE="soar-web"
PULL_DATA_SERVICE="soar-pull-data"
PULL_DATA_TIMER="soar-pull-data"
SITEMAP_SERVICE="soar-sitemap"
SITEMAP_TIMER="soar-sitemap"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   log_error "This script must be run as root (use sudo)"
   exit 1
fi

# Check if deployment directory is provided
if [ -z "$1" ]; then
    log_error "Usage: $0 <deployment_directory>"
    log_error "Example: $0 /tmp/soar/deploy/20231002120000"
    exit 1
fi

DEPLOY_DIR="$1"

if [ ! -d "$DEPLOY_DIR" ]; then
    log_error "Deployment directory does not exist: $DEPLOY_DIR"
    exit 1
fi

log_info "Starting SOAR deployment from: $DEPLOY_DIR"

# Check if binary exists in deployment directory
if [ ! -f "$DEPLOY_DIR/soar" ]; then
    log_error "Binary not found in deployment directory: $DEPLOY_DIR/soar"
    exit 1
fi

# Check GDAL library dependency
log_info "Checking GDAL library dependencies..."
if ! ldd "$DEPLOY_DIR/soar" | grep -q "libgdal"; then
    log_warn "Could not verify GDAL dependency"
else
    GDAL_MISSING=$(ldd "$DEPLOY_DIR/soar" | grep "not found" || true)
    if [ -n "$GDAL_MISSING" ]; then
        log_error "Missing or incompatible GDAL library:"
        echo "$GDAL_MISSING"
        log_info "Upgrading GDAL library..."

        # Try to upgrade GDAL
        if command -v apt-get &> /dev/null; then
            apt-get update -qq
            # Install/upgrade to latest GDAL version available in repos
            apt-get install -y --reinstall libgdal-dev gdal-bin libgdal30 || \
            apt-get install -y --reinstall libgdal-dev gdal-bin || {
                log_error "Failed to upgrade GDAL. Please upgrade manually:"
                log_error "  sudo apt-get update"
                log_error "  sudo apt-get install -y --reinstall libgdal-dev gdal-bin"
                exit 1
            }
            log_info "GDAL upgraded successfully"
        else
            log_error "Cannot auto-upgrade GDAL (apt-get not found)"
            log_error "Please upgrade GDAL manually before deploying"
            exit 1
        fi
    else
        log_info "GDAL library check passed"
    fi
fi

# Stop main services only (NOT timer-controlled services or timers)
log_info "Stopping main SOAR services..."
systemctl stop ${RUN_SERVICE}.service 2>/dev/null && log_info "${RUN_SERVICE}.service stopped" || log_info "${RUN_SERVICE}.service is not running"
systemctl stop ${WEB_SERVICE}.service 2>/dev/null && log_info "${WEB_SERVICE}.service stopped" || log_info "${WEB_SERVICE}.service is not running"

# NOTE: NOT stopping timer-controlled services (soar-pull-data, soar-sitemap)
# They should only be started/stopped by their timers, not manually
# If they're running, let them complete naturally

# NOTE: NOT stopping or restarting timers
# Timers will automatically use the new binary on their next scheduled run
# This prevents interrupting currently running data pulls or sitemap generation
log_info "Timer-controlled services and timers left untouched:"
log_info "  - ${PULL_DATA_SERVICE}.service (will complete if running)"
log_info "  - ${SITEMAP_SERVICE}.service (will complete if running)"
log_info "  - ${PULL_DATA_TIMER}.timer (new binary used on next scheduled run)"
log_info "  - ${SITEMAP_TIMER}.timer (new binary used on next scheduled run)"

# Create service user if it doesn't exist
if ! id "${SERVICE_USER}" &>/dev/null; then
    log_info "Creating ${SERVICE_USER} system user..."
    useradd -r -s /bin/false -d ${DEPLOY_BASE} ${SERVICE_USER}
else
    log_info "User ${SERVICE_USER} already exists"
fi

# Create required directories
log_info "Creating required directories..."
mkdir -p ${DEPLOY_BASE}
mkdir -p ${LOGS_DIR}
mkdir -p /var/soar
mkdir -p ${ARCHIVE_DIR}
mkdir -p ${SITEMAP_DIR}
mkdir -p /etc/soar

log_info "Setting directory permissions..."
chown -R ${SERVICE_USER}:${SERVICE_GROUP} ${DEPLOY_BASE}
chown -R ${SERVICE_USER}:${SERVICE_GROUP} ${LOGS_DIR}
chown -R ${SERVICE_USER}:${SERVICE_GROUP} ${ARCHIVE_DIR}
chown -R ${SERVICE_USER}:${SERVICE_GROUP} ${SITEMAP_DIR}
chown -R ${SERVICE_USER}:${SERVICE_GROUP} /var/soar
chmod 755 ${DEPLOY_BASE}
chmod 755 ${LOGS_DIR}

# Backup current binary if it exists
if [ -f "${BINARY_PATH}/${BINARY_NAME}" ]; then
    BACKUP_PATH="${DEPLOY_BASE}/${BINARY_NAME}.backup.$(date +%s)"
    log_info "Backing up current binary to ${BACKUP_PATH}..."
    cp "${BINARY_PATH}/${BINARY_NAME}" "${BACKUP_PATH}"

    # Keep only the 5 most recent backups
    log_info "Cleaning up old backups (keeping 5 most recent)..."
    ls -t ${DEPLOY_BASE}/${BINARY_NAME}.backup.* 2>/dev/null | tail -n +6 | xargs -r rm -f
fi

# Install new binary
log_info "Installing new binary..."
rm -f "${BINARY_PATH}/${BINARY_NAME}" || true
cp "${DEPLOY_DIR}/soar" "${BINARY_PATH}/${BINARY_NAME}"
chmod +x "${BINARY_PATH}/${BINARY_NAME}"
chown root:root "${BINARY_PATH}/${BINARY_NAME}"
log_info "Binary installed successfully"

# Update Sentry release version in /etc/soar/env
if [ -f "${DEPLOY_DIR}/VERSION" ]; then
    VERSION=$(cat "${DEPLOY_DIR}/VERSION")
    log_info "Setting Sentry release version to: ${VERSION}"

    # Create or update /etc/soar/env with SENTRY_RELEASE
    if [ -f /etc/soar/env ]; then
        # Remove existing SENTRY_RELEASE line if present
        sed -i '/^SENTRY_RELEASE=/d' /etc/soar/env
    else
        touch /etc/soar/env
    fi

    # Append new SENTRY_RELEASE
    echo "SENTRY_RELEASE=${VERSION}" >> /etc/soar/env

    # Ensure proper permissions (readable by service user)
    chown ${SERVICE_USER}:${SERVICE_GROUP} /etc/soar/env
    chmod 640 /etc/soar/env
    log_info "Updated /etc/soar/env with Sentry release version"
else
    log_warn "VERSION file not found in deployment directory, Sentry release version not updated"
fi

# Install service files if they exist
if ls "${DEPLOY_DIR}"/*.service &> /dev/null; then
    log_info "Installing service files..."
    for service in "${DEPLOY_DIR}"/*.service; do
        service_name=$(basename "$service")
        log_info "Installing ${service_name}..."
        cp "$service" /etc/systemd/system/
    done
fi

# Install timer files if they exist
if ls "${DEPLOY_DIR}"/*.timer &> /dev/null; then
    log_info "Installing timer files..."
    for timer in "${DEPLOY_DIR}"/*.timer; do
        timer_name=$(basename "$timer")
        log_info "Installing ${timer_name}..."
        cp "$timer" /etc/systemd/system/
    done
fi

# Reload systemd daemon
log_info "Reloading systemd daemon..."
systemctl daemon-reload

# Enable and start main services
log_info "Enabling and starting main SOAR services..."

# soar-run
log_info "Enabling ${RUN_SERVICE}.service..."
systemctl enable ${RUN_SERVICE}.service
log_info "Starting ${RUN_SERVICE}.service..."
systemctl restart ${RUN_SERVICE}.service || log_warn "Failed to start ${RUN_SERVICE}.service"

# soar-web
log_info "Enabling ${WEB_SERVICE}.service..."
systemctl enable ${WEB_SERVICE}.service
log_info "Starting ${WEB_SERVICE}.service..."
systemctl restart ${WEB_SERVICE}.service || log_warn "Failed to start ${WEB_SERVICE}.service"

# Disable timer-controlled services (they should only be started by their timers)
log_info "Ensuring timer-controlled services are disabled (timer-managed only)..."
systemctl disable ${PULL_DATA_SERVICE}.service 2>/dev/null || true
systemctl disable ${SITEMAP_SERVICE}.service 2>/dev/null || true

# Ensure timers are enabled (but don't restart them to avoid interrupting scheduled runs)
log_info "Ensuring timers are enabled (not restarting to preserve schedule)..."
systemctl is-enabled ${PULL_DATA_TIMER}.timer >/dev/null 2>&1 || {
    log_info "Enabling ${PULL_DATA_TIMER}.timer..."
    systemctl enable ${PULL_DATA_TIMER}.timer
    # Start timer only if it wasn't already enabled (first-time setup)
    log_info "Starting ${PULL_DATA_TIMER}.timer for the first time..."
    systemctl start ${PULL_DATA_TIMER}.timer
}

systemctl is-enabled ${SITEMAP_TIMER}.timer >/dev/null 2>&1 || {
    log_info "Enabling ${SITEMAP_TIMER}.timer..."
    systemctl enable ${SITEMAP_TIMER}.timer
    # Start timer only if it wasn't already enabled (first-time setup)
    log_info "Starting ${SITEMAP_TIMER}.timer for the first time..."
    systemctl start ${SITEMAP_TIMER}.timer
}

log_info "Timers will automatically use new binary on next scheduled run"

# Wait for services to initialize
log_info "Waiting for services to initialize..."
sleep 3

# Check service status
log_info "Checking service status..."

check_service() {
    local service=$1
    if systemctl is-active --quiet "$service"; then
        log_info "$service: ‚úÖ ACTIVE"
        return 0
    else
        log_error "$service: ‚ùå FAILED"
        log_info "Recent logs for $service:"
        journalctl -u "$service" --no-pager -n 10
        return 1
    fi
}

FAILED=0

check_service ${RUN_SERVICE}.service || FAILED=1
check_service ${WEB_SERVICE}.service || FAILED=1
check_service ${PULL_DATA_TIMER}.timer || FAILED=1
check_service ${SITEMAP_TIMER}.timer || FAILED=1

# Show recent logs if any service failed
if [ $FAILED -eq 1 ]; then
    log_error "One or more services failed to start properly"
    log_info "Recent logs from ${RUN_SERVICE}:"
    journalctl -u ${RUN_SERVICE} --no-pager -n 10
    log_info "Recent logs from ${WEB_SERVICE}:"
    journalctl -u ${WEB_SERVICE} --no-pager -n 10
    exit 1
else
    log_info "‚úÖ All services started successfully!"
fi

# Show timer status
log_info ""
log_info "Timer schedule status:"
systemctl list-timers ${PULL_DATA_TIMER}.timer ${SITEMAP_TIMER}.timer --no-pager

# Cleanup deployment directory
log_info ""
log_info "Cleaning up deployment directory..."
rm -rf "$DEPLOY_DIR"

log_info "üöÄ Deployment completed successfully!"
log_info ""
log_info "Service Management:"
log_info "  Status: systemctl status ${RUN_SERVICE} ${WEB_SERVICE}"
log_info "  Timer Status: systemctl list-timers ${PULL_DATA_TIMER}.timer ${SITEMAP_TIMER}.timer"
log_info "  Logs: journalctl -u ${RUN_SERVICE} -f"
log_info "  Web logs: journalctl -u ${WEB_SERVICE} -f"
log_info "  Pull-data logs: journalctl -u ${PULL_DATA_SERVICE} -f"
log_info "  Sitemap logs: journalctl -u ${SITEMAP_SERVICE} -f"
log_info ""
log_info "Note: Timer-controlled services (${PULL_DATA_SERVICE}, ${SITEMAP_SERVICE})"
log_info "      will use the new binary on their next scheduled run"
log_info "      Currently running instances will complete normally without interruption"
